---
layout: post
title: "Working title: Jar Hell"
summary: "TODO"
category: development
tags: [scala, java, community]
---
{% include JB/setup %}

* It can be argued that the single factor that makes modern development more 
  productive is the extensive use of open source libraries.
* However, there are some perils:
  * Regarding library quality: Sturgeons revelation, 90% of anything is shit
  * Regarding security: NPM incident with crypto, TODO: has something similar
    happened with Java/Scala?
  * Regarding licenses: people don't care/check library licenses. Is there any 
    mechanism for this in mvn/ivy/sbt?
  * Regarding the Jar Hell:
    * What is it? Binary compatibility problems and the "diamond" dependency
    * Huge amounts of heat dissipated in this problem (can't be ignored unlike  
      the previous ones)
    
* Is there any solution? Should we suffer these problems as a way to atone our
  sins?
  * When I saw Debian 10 release announcement (TODO: link) I was thunderstruck
    by the revelation: Debian has been solving these problems for decades!
  * Premise: libraries (or "packages") are open source and we know under which
    license are released. That way we can guarantee that just complying licenses
    enter the distribution and we can apply patches on top the original code.
  * The "distribution" has different releases. Each release is build around
    specific versions of core libraries. For example: libc x.xx and linux series
    x.xx in Debian 9 and x.xx and series x.xx in Debian 10.
    Everything else is adapted to work with that core by maintaining a small
    set of patches that address compilation/configuration issues.
    The result are maintained packages. A package has:
    * A maintainer. To become a maintainer you need to gain the trust of the
      community and get your GPG key signed by some number of existing members
      of the community. It's very unlikely that a person like "the NPM hacker"
      will get to the same attack to Debian.
    * Machine-readable metadata used by the software installation/upgrading 
      tools (APT suite). Version, dependencies, license, upstream authors,
      maintainers, etc.
    * The set of patches. These are maintained in separate files from the
      upstream code and are also open source for anyone to use.
  * After a release is ready from prime time packages are frozen except for
    security upgrades. These are, by design, things you can trust to update
    automatically with confidence that nothing is going to break. Interfaces
    won't change, configuration formats won't change. You just get security
    patches. These are sometimes provided by the upstream developers and,
    other times by the Debian maintainers.
  * How a new release version is created? First, the core libraries are bumped and then
    the software around them gets updated, some packages are added or removed
    and problems arise and are fixed. After some time, it is reasonably clear
    that all included packages work well with each other and it is released.
  * What happens with closed software? It benefit greatly for this model of
    releases because you just need to compile your libraries/programs against
    each recent Debian release and provide a repository url. No need to create
    a binary that is statically linked against all libraries (this is analogous
    to the fat-jar anti-pattern).
  * What happens if I need the latest version of a library for a release of 
    Debian that has an older version? You can always compile it against what is
    shipped in that release. However, as this is very common, the work of
    changing dependencies and fixing compilation is shared in dedicated 
    "backport" repositories.
    
* Can I have this for Java/Scala?
  * Fury distributions: which part of this model is supported?
  
## Time to mature
  
It's a matter of maturity. Using so many libraries so liberally has multiplied
developer productivity to a large extent but without the restraint of some
curation culture like the one in Debian it's risks and practical problems might
cancel out the advantages of having access to this galore of functionality.
    
   
  
  
    
    
    